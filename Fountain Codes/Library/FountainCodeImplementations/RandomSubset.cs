using System;

namespace Library.FountainCodeImplementations
{
	/// <summary>
	/// An implementation in which encoding symbols are generated by randomly choosing which original data symbols get XOR'd together. There's an equal probability that any of the (2^NumSymbols - 1) possible non-zero combinations of original data symbols will be chosen
	/// </summary>
	public class RandomSubset : IFountainCodeImplementation
	{
		/// <summary>
		/// The source of randomness to use
		/// </summary>
		Random random;

		/// <summary>
		/// The number of symbols that this implementation is set up to handle
		/// </summary>
		public int NumSymbols { get; private set; }

		/// <summary>
		/// Sets up this implementation, which will randomly choose original data symbols to XOR together with equal probability
		/// </summary>
		/// <param name="random"></param>
		/// <param name="numSymbols"></param>
		public RandomSubset(Random random, int numSymbols)
		{
			this.NumSymbols = numSymbols;
			this.random = random;
		}

		/// <summary>
		/// Returns an array of coefficients in which each element has a 50% chance of being set, except this doesn't return an array of coefficients in which none of the elements are set
		/// </summary>
		/// <param name="symbolID"></param>
		/// <param name="complexity">The number of operations that had to be performed</param>
		/// <returns></returns>
		public bool[] GenerateCoefficients(long symbolID, ref int complexity)
		{
			var atLeastOneSet = false; // This will tell us whether there's at least one bit set in the coefficients array
			var coefficients = new bool[this.NumSymbols]; // Initialize the coefficients array
			complexity += this.NumSymbols;
			while (!atLeastOneSet) // Loop until the coefficients array has at least one bit set
			{
				complexity++;
				for (var i = 0; i < coefficients.Length; i++) // Set the bits of it randomly
				{
					complexity++;
					atLeastOneSet |= // This will wind up taking the OR of all the coefficients. If any one of them is set then this will wind up being true, and the while loop will stop
						coefficients[i] = (this.random.NextDouble() < 0.5); // There's a 50/50 chance that any bit will be set
				}
			}

			return coefficients;
		}
	}
}
