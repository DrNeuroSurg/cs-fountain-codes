<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Library</name>
    </assembly>
    <members>
        <member name="T:Library.DiscreteDistributions.DiscretePMF">
            <summary>
            Implements a probability mass function based on any discrete cumulative distribution function. https://en.wikipedia.org/wiki/Probability_mass_function
            </summary>
        </member>
        <member name="M:Library.DiscreteDistributions.DiscretePMF.#ctor(System.Random,System.Double[])">
            <summary>
            Creates a new probability mass function from the given cumulative distribution function and uniform random number generator. https://en.wikipedia.org/wiki/Probability_mass_function
            </summary>
            <param name="random"></param>
            <param name="cdf">The values in this array must be sorted from least to greatest, and the last element must equal 1. https://en.wikipedia.org/wiki/Cumulative_distribution_function</param>
        </member>
        <member name="M:Library.DiscreteDistributions.DiscretePMF.Generate">
            <summary>
            Generates a random point from this probability mass function
            </summary>
            <returns>An integer between 0 (inclusive) and cdf.Length (exclusive)</returns>
        </member>
        <member name="M:Library.DiscreteDistributions.DiscretePMF.Visualize(System.Int32,System.Int32)">
            <summary>
            Returns a horizontal bar graph of the given width showing average output of this probability mass function.
            </summary>
            <param name="resolution">The number of numbers to draw from the random number generator that was given to the constructor. Using at least 10e5 gives only a small amount of variance between calls to this function</param>
            <param name="width">Maximum width in characters for each line in the returned array</param>
            <returns>An array of lines. Each line is a string of * characters, the number of which shows the relative weight of that index</returns>
        </member>
        <member name="P:Library.DiscreteDistributions.DiscretePMF.Max">
            <summary>
            Gets the number of elements in the CDF that was provided to the constructor
            </summary>
        </member>
        <member name="T:Library.FountainCodeImplementations.SophisticatedCarousel">
            <summary>
            A fountain code which cycles through all the elements of the multiplicative group of a finite field to determine which symbols get XOR'd together for encoding symbols
            </summary>
        </member>
        <member name="T:Library.FountainCodeImplementations.IFountainCodeImplementation">
            <summary>
            The core of a Fountain Code
            </summary>
        </member>
        <member name="M:Library.FountainCodeImplementations.IFountainCodeImplementation.GenerateCoefficients(System.Int64,System.Int32@)">
            <summary>
            Calculates and returns the needed number of coefficients for the given symbol ID. Flagged bits indicate which symbols need to be XOR'd together for this encoding symbol
            </summary>
            <param name="symbolID"></param>
            <param name="complexity">The number of operations that had to be performed to generate these coefficients</param>
            <returns></returns>
        </member>
        <member name="P:Library.FountainCodeImplementations.IFountainCodeImplementation.NumSymbols">
            <summary>
            Returns the number of original data symbols this implementation is good for
            </summary>
        </member>
        <member name="F:Library.FountainCodeImplementations.SophisticatedCarousel.lastPolynomial">
            <summary>
            The polynomial that represents the coefficients of the last symbol that was generated
            </summary>
        </member>
        <member name="M:Library.FountainCodeImplementations.SophisticatedCarousel.#ctor(System.Int32)">
            <summary>
            Generates a sophisticated carousel that will handle the given number of symbols
            </summary>
            <param name="numSymbols"></param>
        </member>
        <member name="M:Library.FountainCodeImplementations.SophisticatedCarousel.GenerateCoefficients(System.Int64,System.Int32@)">
            <summary>
            Generates the set of pointers for which symbols need to be XOR'd together to make the encoding symbol for the given symbol ID
            </summary>
            <param name="symbolID"></param>
            <param name="complexity"></param>
            <returns></returns>
            <remarks>This method takes a shortcut and is much faster when you generate successive symbol IDs</remarks>
        </member>
        <member name="P:Library.FountainCodeImplementations.SophisticatedCarousel.NumSymbols">
            <summary>
            Returns the number of symbols that this carousel fountain code is set up to handle
            </summary>
        </member>
        <member name="T:Library.GaussianElimination.GaussianEliminationGaloisField`1">
            <summary>
            A class which does Gaussian Elimination to solve a system of equations. The coefficients are in GF(2) and the solutions are in GF(8N), so only the swap and XOR operations are used. Inspired by https://en.wikipedia.org/wiki/Gaussian_elimination
            </summary>
        </member>
        <member name="T:Library.GaussianElimination.IGaussianElimination`1">
            <summary>
            Defines something that does Gaussian Elimination to solve a system of equations
            </summary>
        </member>
        <member name="M:Library.GaussianElimination.IGaussianElimination`1.Generate(Library.Symbol{`0}[],System.Int32@)">
            <summary>
            Performs the sequence of steps in reverse on the given input
            </summary>
            <param name="variables"></param>
            <param name="complexity">The number of operations that had to be performed</param>
            <returns></returns>
        </member>
        <member name="M:Library.GaussianElimination.IGaussianElimination`1.Solve(Library.Symbol{`0}[],System.Int32@)">
            <summary>
            Follows the precomputed steps to give the values of the variables. Returns nulls where symbols can't be solved
            </summary>
            <param name="solutions"></param>
            <param name="complexity">The number of operations that had to be performed</param>
            <returns></returns>
        </member>
        <member name="F:Library.GaussianElimination.GaussianEliminationGaloisField`1.numColumns">
            <summary>
            The number of columns in the coefficient matrix
            </summary>
        </member>
        <member name="F:Library.GaussianElimination.GaussianEliminationGaloisField`1.numRows">
            <summary>
            The number of rows in the coefficient matrix
            </summary>
        </member>
        <member name="F:Library.GaussianElimination.GaussianEliminationGaloisField`1.steps">
            <summary>
            The sequence of steps to perform to solve the system of equations
            </summary>
        </member>
        <member name="M:Library.GaussianElimination.GaussianEliminationGaloisField`1.Create(System.Boolean[][],System.Int32@)">
            <summary>
            Creates a new solver object by calculating the steps required to solve for the given coefficients.
            
            If the given coefficients can't be solved for then null is returned.
            
            This function has time complexity O(n^2) where n is the number of rows
            </summary>
            <param name="coefficients"></param>
            <param name="complexity">The number of operations that had to be performed</param>
            <returns></returns>
        </member>
        <member name="M:Library.GaussianElimination.GaussianEliminationGaloisField`1.Generate(Library.Symbol{`0}[],System.Int32@)">
            <summary>
            Performs the sequence of steps in reverse on the given input.
            </summary>
            <param name="variables"></param>
            <param name="complexity">The number of operations that had to be performed</param>
            <returns></returns>
        </member>
        <member name="M:Library.GaussianElimination.GaussianEliminationGaloisField`1.NumColumns(System.Boolean[][])">
            <summary>
            Returns the number of columns in the given array
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Library.GaussianElimination.GaussianEliminationGaloisField`1.NumRows(System.Boolean[][])">
            <summary>
            Returns the number of rows in the given array
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Library.GaussianElimination.GaussianEliminationGaloisField`1.Solve(Library.Symbol{`0}[],System.Int32@)">
            <summary>
            Follows the precomputed steps to give the values of the variables
            </summary>
            <param name="solutions"></param>
            <param name="complexity">The number of operations that had to be performed</param>
            <returns></returns>
        </member>
        <member name="M:Library.GaussianElimination.GaussianEliminationGaloisField`1.SolveInner(System.Collections.Generic.IEnumerable{Library.GaussianElimination.GaussianEliminationGaloisField{`0}.Step},Library.Symbol{`0}[],System.Int32@)">
            <summary>
            Performs the given sequence of steps against the given input
            </summary>
            <param name="steps"></param>
            <param name="input"></param>
            <param name="complexity">The number of operations that had to be performed</param>
            <returns></returns>
        </member>
        <member name="M:Library.GaussianElimination.GaussianEliminationGaloisField`1.SwapRows(System.Boolean[][],System.Int64,System.Int64)">
            <summary>
            Swaps two rows in the given two-dimensional array
            </summary>
            <param name="equations"></param>
            <param name="fromRow"></param>
            <param name="toRow"></param>
            <returns></returns>
        </member>
        <member name="M:Library.GaussianElimination.GaussianEliminationGaloisField`1.XORRows(System.Boolean[][],System.Int64,System.Int64)">
            <summary>
            XORs one row with another
            </summary>
            <param name="equations"></param>
            <param name="fromRow"></param>
            <param name="toRow"></param>
            <returns></returns>
        </member>
        <member name="T:Library.GaussianElimination.GaussianEliminationGaloisField`1.Operation">
            <summary>
            An operation that can be performed between two bytes
            </summary>
        </member>
        <member name="T:Library.GaussianElimination.GaussianEliminationGaloisField`1.Step">
            <summary>
            Something which performs an operation from an index to another index
            </summary>
        </member>
        <member name="T:Library.FountainCodeImplementations.Carousel">
            <summary>
            A fountain code implementation that sends the original data symbols in order and then repeats continually. This presents the user with the Coupon Collector's Problem (https://en.wikipedia.org/wiki/Coupon_collector%27s_problem)
            </summary>
        </member>
        <member name="M:Library.FountainCodeImplementations.Carousel.#ctor(System.Int32)">
            <summary>
            Sets up a new carousel that will handle the given number of symbols
            </summary>
            <param name="numSymbols"></param>
        </member>
        <member name="M:Library.FountainCodeImplementations.Carousel.GenerateCoefficients(System.Int64,System.Int32@)">
            <summary>
            Returns a boolean array with the (symbolID % NumSymbols)th bit set. This corresponds to sending that original data symbol by itself
            </summary>
            <param name="symbolID"></param>
            <param name="complexity">The number of operations that had to be performed</param>
            <returns></returns>
        </member>
        <member name="P:Library.FountainCodeImplementations.Carousel.NumSymbols">
            <summary>
            The number of original data symbols that this carousel will handle
            </summary>
        </member>
        <member name="T:Library.FountainCodeImplementations.LubyTransform">
            <summary>
            An implementation of Luby Transform. To better understand the underlying principals, it's recommended to read Michael Luby's "LT Codes" paper given in the Proceedings of the 43 rd Annual IEEE Symposium on Foundations of Computer Science
            </summary>
        </member>
        <member name="F:Library.FountainCodeImplementations.LubyTransform.pmf">
            <summary>
            The probability distribution to use to pick the degree of each encoding symbol
            </summary>
        </member>
        <member name="F:Library.FountainCodeImplementations.LubyTransform.random">
            <summary>
            The source of randomness to use
            </summary>
        </member>
        <member name="M:Library.FountainCodeImplementations.LubyTransform.#ctor(System.Random,System.Int32,System.Int32,System.Double)">
            <summary>
            Creates a new Luby Transform implementation with the given parameters
            </summary>
            <param name="random">A source of randomness. Make sure this source of randomness is thread-safe</param>
            <param name="numSymbols">The number of original data symbols that this implementation will deal with</param>
            <param name="r">The expected "ripple" size (see Michael Luby's "LT Codes" paper). Basically this increases the probability that numSymbols/r bits are set in the generated coefficients. 2 seems to work well</param>
            <param name="delta">The probability that a random walk of length k deviates from its mean by more than ln(k/delta)*sqrt(k) is at most this number. In other words, a smaller delta makes the underlying Robust Soliton Distribution more robust, so a smaller number seems to be better</param>
        </member>
        <member name="M:Library.FountainCodeImplementations.LubyTransform.GenerateCoefficients(System.Int64,System.Int32@)">
            <summary>
            Generates a random set of coefficients. The number of set coefficients is a number drawn from the Robust Soliton Distribution that was initialized in the constructor
            </summary>
            <param name="symbolID">For Luby Transform, the symbol ID has no bearing on the coefficients</param>
            <param name="complexity">The number of operations that had to be performed</param>
            <returns></returns>
        </member>
        <member name="P:Library.FountainCodeImplementations.LubyTransform.NumSymbols">
            <summary>
            The number of original data symbols that this implementation is good for
            </summary>
        </member>
        <member name="T:Library.FountainCodeImplementations.RandomSubset">
            <summary>
            An implementation in which encoding symbols are generated by randomly choosing which original data symbols get XOR'd together. There's an equal probability that any of the (2^NumSymbols - 1) possible non-zero combinations of original data symbols will be chosen
            </summary>
        </member>
        <member name="F:Library.FountainCodeImplementations.RandomSubset.random">
            <summary>
            The source of randomness to use
            </summary>
        </member>
        <member name="M:Library.FountainCodeImplementations.RandomSubset.#ctor(System.Random,System.Int32)">
            <summary>
            Sets up this implementation, which will randomly choose original data symbols to XOR together with equal probability
            </summary>
            <param name="random"></param>
            <param name="numSymbols"></param>
        </member>
        <member name="M:Library.FountainCodeImplementations.RandomSubset.GenerateCoefficients(System.Int64,System.Int32@)">
            <summary>
            Returns an array of coefficients in which each element has a 50% chance of being set, except this doesn't return an array of coefficients in which none of the elements are set
            </summary>
            <param name="symbolID"></param>
            <param name="complexity">The number of operations that had to be performed</param>
            <returns></returns>
        </member>
        <member name="P:Library.FountainCodeImplementations.RandomSubset.NumSymbols">
            <summary>
            The number of symbols that this implementation is set up to handle
            </summary>
        </member>
        <member name="T:Library.FountainCodeImplementations.SpecialLubyTransform">
            <summary>
            Behaves like the Luby Transform code with delta set to zero. In other words, there's a 100% chance that the chosen degree will be (numSymbols / r)
            </summary>
        </member>
        <member name="F:Library.FountainCodeImplementations.SpecialLubyTransform.r">
            <summary>
            Luby's expected "ripple" size
            </summary>
        </member>
        <member name="F:Library.FountainCodeImplementations.SpecialLubyTransform.random">
            <summary>
            The source of randomness to use
            </summary>
        </member>
        <member name="M:Library.FountainCodeImplementations.SpecialLubyTransform.#ctor(System.Random,System.Int32,System.Int32)">
            <summary>
            Sets up a special case of Luby Transform which acts as though delta is zero. In other words, there's a 100% chance that the generated degree will be (numSymbols / r)
            </summary>
            <param name="random"></param>
            <param name="numSymbols"></param>
            <param name="r"></param>
        </member>
        <member name="M:Library.FountainCodeImplementations.SpecialLubyTransform.GenerateCoefficients(System.Int64,System.Int32@)">
            <summary>
            Generates an array of coeffients in which (the smallest odd number at least as large as (NumSymbols / r)) of them are set
            </summary>
            <param name="symbolID">The symbol ID has no bearing on how coefficients are generated in this implementation</param>
            <param name="complexity">The number of operations that had to be performed</param>
            <returns></returns>
        </member>
        <member name="P:Library.FountainCodeImplementations.SpecialLubyTransform.NumSymbols">
            <summary>
            The number of symbols that this implementation can handle
            </summary>
        </member>
        <member name="T:Library.GaussianElimination.Polynomial">
            <summary>
            Represents a polynomial that's good for GF(2^n)
            </summary>
        </member>
        <member name="F:Library.GaussianElimination.Polynomial.One">
            <summary>
            Represents the polynomial 1
            </summary>
        </member>
        <member name="F:Library.GaussianElimination.Polynomial.X">
            <summary>
            Represents the polynomial X
            </summary>
        </member>
        <member name="F:Library.GaussianElimination.Polynomial.coefficients">
            <summary>
            This polynomial's coefficients in Little-Endian order (e.g. 1 + x + x^2 + ...)
            </summary>
        </member>
        <member name="M:Library.GaussianElimination.Polynomial.#ctor(System.Boolean[])">
            <summary>
            Creates a new polynomial object from the given coefficients. If the given coefficients can be trimmed down then a copy is made and then trimmed down. Otherwise the given array is used without copying
            </summary>
            <param name="coefficients">The coefficients from smallest degree to largest</param>
        </member>
        <member name="M:Library.GaussianElimination.Polynomial.#ctor(System.Numerics.BigInteger)">
            <summary>
            Creates a new polynomial object from the given integer
            </summary>
            <param name="decimalForm"></param>
        </member>
        <member name="M:Library.GaussianElimination.Polynomial.#ctor(System.Int32[])">
            <summary>
            Accepts a list of bits that should be set in the coefficient. This is more convenient if you're dealing with a list like http://www.ams.org/journals/mcom/1992-59-200/S0025-5718-1992-1134730-7/S0025-5718-1992-1134730-7.pdf
            </summary>
            <param name="setBits"></param>
        </member>
        <member name="M:Library.GaussianElimination.Polynomial.ConvertToPolynomialBits(System.Numerics.BigInteger)">
            <summary>
            Gets the equivalent binary number for the given integer, then reverses the order of the bits for use as a polynomial's coefficients
            </summary>
            <param name="decimalForm"></param>
            <returns></returns>
        </member>
        <member name="M:Library.GaussianElimination.Polynomial.Clone">
            <summary>
            Creates a deep copy of this polynomial
            </summary>
            <returns></returns>
        </member>
        <member name="M:Library.GaussianElimination.Polynomial.CompareTo(Library.GaussianElimination.Polynomial)">
            <summary>
            Returns a number comparing this polynomial to the other
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Library.GaussianElimination.Polynomial.Equals(System.Object)">
            <summary>
            Indicates if the given object is a polynomial that equals this one
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Library.GaussianElimination.Polynomial.GetDecimalForm(System.Numerics.BigInteger)">
            <summary>
            Returns the decimal form of the given index, assuming that this polynomial is a primitive polynomial for a finite field
            </summary>
            <param name="indexForm"></param>
            <returns></returns>
        </member>
        <member name="M:Library.GaussianElimination.Polynomial.GetIndexForm(System.Numerics.BigInteger)">
            <summary>
            Returns the index form of the given decimal, assuming that this polynomial is a primitive polynomial for a finite field
            </summary>
            <param name="decimalForm"></param>
            <returns></returns>
        </member>
        <member name="M:Library.GaussianElimination.Polynomial.GetNumber">
            <summary>
            Converts this polynomial into its base-10 equivalent (e.g. 1 + x => 3)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Library.GaussianElimination.Polynomial.ToString">
            <summary>
            Returns a string representation of this polynomial
            </summary>
            <returns></returns>
        </member>
        <member name="M:Library.GaussianElimination.Polynomial.Add(Library.GaussianElimination.Polynomial,Library.GaussianElimination.Polynomial)">
            <summary>
            Returns a new polynomial that is the result of summing the two given polynomials
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Library.GaussianElimination.Polynomial.Mod(Library.GaussianElimination.Polynomial,Library.GaussianElimination.Polynomial)">
            <summary>
            Returns the remainder after dividing the given polynomial by the given modulus polynomial
            </summary>
            <param name="polynomial"></param>
            <param name="modulus"></param>
            <returns></returns>
        </member>
        <member name="M:Library.GaussianElimination.Polynomial.MultiplicativeInverse(Library.GaussianElimination.Polynomial,Library.GaussianElimination.Polynomial)">
            <summary>
            Finds the multiplicative inverse of the given polynomial by multiplying it with itself 2^n - 2 times
            </summary>
            <param name="a"></param>
            <param name="modulus"></param>
            <returns></returns>
        </member>
        <member name="M:Library.GaussianElimination.Polynomial.Multiply(Library.GaussianElimination.Polynomial,Library.GaussianElimination.Polynomial)">
            <summary>
            Returns the result of multiplying the two given polynomials
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Library.GaussianElimination.Polynomial.op_Equality(Library.GaussianElimination.Polynomial,Library.GaussianElimination.Polynomial)">
            <summary>
            Returns true if both polynomials are non-null and have the same degree and have identical coefficients
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Library.GaussianElimination.Polynomial.op_Inequality(Library.GaussianElimination.Polynomial,Library.GaussianElimination.Polynomial)">
            <summary>
            Returns false if both polynomials have the same degree and have identical coefficients, or if either is null
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Library.GaussianElimination.Polynomial.op_Addition(Library.GaussianElimination.Polynomial,Library.GaussianElimination.Polynomial)">
            <summary>
            Adds the two polynomials together
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Library.GaussianElimination.Polynomial.op_Multiply(Library.GaussianElimination.Polynomial,Library.GaussianElimination.Polynomial)">
            <summary>
            Multiplies the two polynomials together
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Library.GaussianElimination.Polynomial.op_Modulus(Library.GaussianElimination.Polynomial,Library.GaussianElimination.Polynomial)">
            <summary>
            Returns the remainder after division of the modulus
            </summary>
            <param name="a"></param>
            <param name="modulus"></param>
            <returns></returns>
        </member>
        <member name="P:Library.GaussianElimination.Polynomial.Degree">
            <summary>
            Gets this polynomial's degree (the highest power of x e.g. deg(1 + x) = 1)
            </summary>
        </member>
        <member name="P:Library.GaussianElimination.Polynomial.Coefficients">
            <summary>
            Gets a copy of this polynomial's coefficients. Keep in mind that they're in Little-Endian order (e.g. 1 + x + x^2)
            </summary>
        </member>
        <member name="P:Library.GaussianElimination.Polynomial.IsOne">
            <summary>
            Indicates whether this polynomial is 1
            </summary>
        </member>
        <member name="P:Library.GaussianElimination.Polynomial.IsZero">
            <summary>
            Indicates whether this polynomial is zero
            </summary>
        </member>
        <member name="P:Library.GaussianElimination.Polynomial.Number">
            <summary>
            Same as calling GetNumber()
            </summary>
        </member>
        <member name="T:Library.GaussianElimination.PrecomputedPrimitivePolynomials">
            <summary>
            Stores precomputed primitive polynomials for GF(2^n) for various values of n
            </summary>
        </member>
        <member name="F:Library.GaussianElimination.PrecomputedPrimitivePolynomials.primitivePolynomials">
            <summary>
            This is a list of primitive polynomials from http://poincare.matf.bg.ac.rs/~ezivkovm/publications/primpol1.pdf
            </summary>
        </member>
        <member name="M:Library.GaussianElimination.PrecomputedPrimitivePolynomials.#cctor">
            <summary>
            Static constructor that stores away all the precomuted primitive polynomials
            </summary>
        </member>
        <member name="M:Library.GaussianElimination.PrecomputedPrimitivePolynomials.Get(System.Int32)">
            <summary>
            Returns a precomputed primitive polynomial for the given order. Every order from 2 through 310 is included, as well as many more higher than that (including 4423) but with increasingly wider gaps between them
            </summary>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="T:Library.Input.ConsoleUtil">
            <summary>
            A set of functions related to getting input from the console
            </summary>
        </member>
        <member name="M:Library.Input.ConsoleUtil.Choose(System.String,System.String[])">
            <summary>
            Prompts the user to pick one option from a set. Returns the zero-based index of the chosen option
            </summary>
            <param name="title"></param>
            <param name="options"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Input.ConsoleUtil.Prompt(System.String)">
            <summary>
            Prints the given message to console and blocks until the user enters a line, then returns that string
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Input.ConsoleUtil.ReadPasswordLine(System.Char)">
            <summary>
            Reads a password from the console, printing the given passwordChar in place of plain text
            </summary>
            <param name="passwordChar">The character to print in place of input. Use '\0' to have no characters printed at all</param>
            <returns>The inputted password, or null if ESC was pressed</returns>
        </member>
        <member name="M:Library.Input.ConsoleUtil.Write(System.Object,System.ConsoleColor)">
            <summary>
            Writes something out to the console using the specified foreground color
            </summary>
            <param name="o"></param>
            <param name="color"></param>
        </member>
        <member name="M:Library.Input.ConsoleUtil.WriteLine(System.Object,System.ConsoleColor)">
            <summary>
            Writes something out to the console using the specified foreground color, appending a newline at the end
            </summary>
            <param name="o"></param>
            <param name="color"></param>
        </member>
        <member name="T:Library.Numbers.Binary">
            <summary>
            A class to help with binary numbers
            </summary>
        </member>
        <member name="M:Library.Numbers.Binary.ComputeGrayCode(System.UInt64)">
            <summary>
            Computes the ith gray code value
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.Binary.GetBinaryString(System.Int32,System.Int64)">
            <summary>
            Returns the binary representation of the given value. The string will be at least numBinaryDigits long
            </summary>
            <param name="numBinaryDigits"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.Binary.GetRandomBits(System.Int32,System.Random)">
            <summary>
            Randomly populates a boolean array
            </summary>
            <param name="numBits"></param>
            <param name="random"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.Binary.IsBitSet(System.UInt64,System.Byte)">
            <summary>
            Determines if the given bit is set in the given number
            </summary>
            <param name="number"></param>
            <param name="bit"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.Binary.FlipBit(System.UInt64,System.Byte)">
            <summary>
            Returns the result of flipping the given bit index of the given number
            </summary>
            <param name="number"></param>
            <param name="bit"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.Binary.GetNumNonZeroBits(System.UInt64)">
            <summary>
            Returns the number of non-zero bits in the binary representation of the given number
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.Binary.NextPermutation(System.Int64)">
            <summary>
            Gets the next number in a permutation that has the same number of bits set as the given number.
            
            The number of different permutations of an n-bit long number with m bits set is given by (n choose m).
            The PascalsTriangle class in this toolkit can generate that number for you.
            
            Based on http://stackoverflow.com/a/13614164/3063273
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.Binary.SetBit(System.UInt64,System.Byte,System.Boolean)">
            <summary>
            Returns the result of setting the given bit index of the given number
            </summary>
            <param name="number"></param>
            <param name="bitIndex"></param>
            <param name="newValue"></param>
            <returns></returns>
        </member>
        <member name="T:Library.Numbers.BinaryNumber">
            <summary>
            An unsigned binary number of arbitrary length. Note this is just an extension of LinkedList&lt;bool&gt;, so you can iterate through each of the digits and can add/remove digits. The most significant digit is first
            </summary>
        </member>
        <member name="M:Library.Numbers.BinaryNumber.#ctor">
            <summary>
            Makes the equivalent of a compacted number 0
            </summary>
        </member>
        <member name="M:Library.Numbers.BinaryNumber.#ctor(System.Collections.Generic.IEnumerable{System.Boolean})">
            <summary>
            Makes a binary number based on the collection of bits given in Big Endian format
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Library.Numbers.BinaryNumber.#ctor(System.String)">
            <summary>
            Builds a new (compacted) binary number from the given binary string
            </summary>
            <param name="binaryString"></param>
        </member>
        <member name="M:Library.Numbers.BinaryNumber.#ctor(System.Numerics.BigInteger)">
            <summary>
            Constructs a new BinaryNumber from the given integer
            </summary>
            <param name="integer"></param>
        </member>
        <member name="M:Library.Numbers.BinaryNumber.Compact">
            <summary>
            Removes leading falses
            </summary>
        </member>
        <member name="M:Library.Numbers.BinaryNumber.LeastSignificantBit">
            <summary>
            Returns the least significant bit
            </summary>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.BinaryNumber.MostSignificantBitIndex">
            <summary>
            Finds the index of the most significant bit that's set. The index is the number of digits to the left from the end (1 if there's only a single bit and it's set). Returns 0 if no bits are set
            </summary>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.BinaryNumber.RotateLeft">
            <summary>
            Rotates all the bits left, appending a false as the least-significant bit
            </summary>
        </member>
        <member name="M:Library.Numbers.BinaryNumber.RotateRight">
            <summary>
            Rotates all the bits right, discarding the least-significant bit
            </summary>
        </member>
        <member name="M:Library.Numbers.BinaryNumber.ToBigInteger">
            <summary>
            Converts this binary number into a BigInteger
            </summary>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.BinaryNumber.ToString">
            <summary>
            Returns a string representation of this binary number. The most significant bit comes first
            </summary>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.BinaryNumber.Operate(Library.Numbers.BinaryNumber,Library.Numbers.BinaryNumber,System.Func{System.Boolean,System.Boolean,System.Boolean,System.Boolean},System.Func{System.Boolean,System.Boolean,System.Boolean,System.Boolean},System.Func{System.Boolean,System.Boolean,System.Boolean},System.Func{System.Boolean,System.Boolean,System.Boolean},System.Func{System.Boolean,System.Boolean})">
            <summary>
            Performs an abstract operation on two numbers, returning the compacted result
            </summary>
            <param name="a">One binary number</param>
            <param name="b">The other binary number</param>
            <param name="bitwiseFn">A function with parameters a_i, b_i, state and returning an operation on those</param>
            <param name="stateFn">A function that calculates the new state based on a_i, b_i, and the state</param>
            <param name="remainderBitwiseFn">A function that returns an operation on r_i, state. r_i is a part of the remaining digits (when one binary number is longer than the other)</param>
            <param name="remainderStateFn">A function that calculates the state in the remainder case</param>
            <param name="followupFn">A function that can optionally include an additional digit based on the state after everything completes</param>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.BinaryNumber.op_ExclusiveOr(Library.Numbers.BinaryNumber,Library.Numbers.BinaryNumber)">
            <summary>
            Performs the bitwise XOR of a and b, returning a new binary number
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.BinaryNumber.op_BitwiseAnd(Library.Numbers.BinaryNumber,Library.Numbers.BinaryNumber)">
            <summary>
            Performs the bitwise AND of a and b, returning the new binary number
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.BinaryNumber.op_BitwiseOr(Library.Numbers.BinaryNumber,Library.Numbers.BinaryNumber)">
            <summary>
            Performs the bitwise OR of a and b, returning the new binary number
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.BinaryNumber.op_OnesComplement(Library.Numbers.BinaryNumber)">
            <summary>
            Performs the bitwise NOT of a, returning the new number. Note that this will only flip bits after (and including) the most significant bit that is set, so ~(~A) != A. E.g. ~100 = 11, but ~11 = 0
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.BinaryNumber.op_Equality(Library.Numbers.BinaryNumber,Library.Numbers.BinaryNumber)">
            <summary>
            Returns true if the two numbers represent the same number
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.BinaryNumber.op_Inequality(Library.Numbers.BinaryNumber,Library.Numbers.BinaryNumber)">
            <summary>
            Returns the opposite of a == b
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.BinaryNumber.op_GreaterThan(Library.Numbers.BinaryNumber,Library.Numbers.BinaryNumber)">
            <summary>
            Determines if a is greater than b
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.BinaryNumber.op_GreaterThanOrEqual(Library.Numbers.BinaryNumber,Library.Numbers.BinaryNumber)">
            <summary>
            Determines if a is at least as large as b
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.BinaryNumber.op_LessThan(Library.Numbers.BinaryNumber,Library.Numbers.BinaryNumber)">
            <summary>
            Determines if a is less than b
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.BinaryNumber.op_LessThanOrEqual(Library.Numbers.BinaryNumber,Library.Numbers.BinaryNumber)">
            <summary>
            Determines if b is at least as large as a
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.BinaryNumber.op_Addition(Library.Numbers.BinaryNumber,Library.Numbers.BinaryNumber)">
            <summary>
            Performs the addition of a and b, returning a new binary number
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.BinaryNumber.op_Subtraction(Library.Numbers.BinaryNumber,Library.Numbers.BinaryNumber)">
            <summary>
            Performs the subtraction of b from a, returning a new binary number. Throws an exception if b > a
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.BinaryNumber.op_Multiply(Library.Numbers.BinaryNumber,Library.Numbers.BinaryNumber)">
            <summary>
            Performs multiplication of a and b, returning the new binary number
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.BinaryNumber.op_Division(Library.Numbers.BinaryNumber,Library.Numbers.BinaryNumber)">
            <summary>
            Performs integer division (the floor of the quotient) of dividend / divisor
            </summary>
            <param name="dividend"></param>
            <param name="divisor"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.BinaryNumber.op_Modulus(Library.Numbers.BinaryNumber,Library.Numbers.BinaryNumber)">
            <summary>
            Performs the remainder after integer division
            </summary>
            <param name="dividend"></param>
            <param name="modulus"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.BinaryNumber.LongDivision(Library.Numbers.BinaryNumber,Library.Numbers.BinaryNumber,Library.Numbers.BinaryNumber@,Library.Numbers.BinaryNumber@)">
            <summary>
            Performs an integer division, returning the quotient and remainder after division
            </summary>
            <param name="dividend"></param>
            <param name="divisor"></param>
            <param name="remainder"></param>
            <param name="quotient"></param>
        </member>
        <member name="T:Library.Numbers.Bytes">
            <summary>
            A class which helps deal with numbers and byte arrays
            </summary>
        </member>
        <member name="M:Library.Numbers.Bytes.Compact(System.UInt64)">
            <summary>
            Returns a byte array of the given number that's just large enough to hold it
            </summary>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.Bytes.Compact(System.UInt64,System.UInt64)">
            <summary>
            Returns a byte array of the given number that's large enough to hold the given maximum number.
            
            For example, for number=0x8F and maxNumber=0xFFFF, this returns {0x00, 0x8F}
            </summary>
            <param name="number"></param>
            <param name="maxNumber"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.Bytes.GetMinimumNumberOfBytesForHolding(System.UInt64)">
            <summary>
            Returns the minimum number of bytes necessary to hold the given number.
            </summary>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.Bytes.GetRandomBytes(System.Int32,System.Random)">
            <summary>
            Returns an array of bytes of the specified size
            </summary>
            <param name="numBytes"></param>
            <param name="random"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Numbers.Bytes.Uncompact(System.Byte[])">
            <summary>
            Returns an unsigned 64-bit integer from the given array of bytes. The array can be up to 8 bytes long
            </summary>
            <param name="bytes"></param>
            <returns></returns>
        </member>
        <member name="T:Library.Randomness.Permutator`1">
            <summary>
            Helps with permutating things
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Library.Randomness.Permutator`1.Permutate(`0[],System.Random)">
            <summary>
            Permutates the given items in place so that an element has equal probability of ending up anywhere in the array
            </summary>
            <param name="items"></param>
            <param name="random">The random number generator to use for the permutation</param>
            <remarks>Follows the Fisher-Yates shuffle https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle, so this has time complexity O(n)</remarks>
        </member>
        <member name="T:Library.DiscreteDistributions.RobustSolitonDistribution">
            <summary>
            Another implementation of the Robust Soliton Distribution's CDF
            </summary>
        </member>
        <member name="M:Library.DiscreteDistributions.RobustSolitonDistribution.GenerateCDF(System.Int32,System.Int32,System.Double)">
            <summary>
            Generates a cumulative density function for the Robust Soliton Distribution
            </summary>
            <param name="k">The number of symbols</param>
            <param name="r">The expected ripple size</param>
            <param name="delta">The probability of a random walk deviating from its mean by more than a certain amount</param>
            <returns></returns>
            <remarks>This is a very straightforward implementation based on Michael Luby's "LT Codes" paper given in the Proceedings of the 43 rd Annual IEEE Symposium on Foundations of Computer Science</remarks>
        </member>
        <member name="T:Library.Sender">
            <summary>
            A class which generates encoding symbols by XOR'ing together data symbols
            </summary>
        </member>
        <member name="F:Library.Sender.data">
            <summary>
            The data that will be combined into encoding symbols
            </summary>
        </member>
        <member name="F:Library.Sender.implementation">
            <summary>
            The implementation we should use to generate coefficients
            </summary>
        </member>
        <member name="F:Library.Sender.symbolID">
            <summary>
            The ID of the next encoding symbol to send
            </summary>
        </member>
        <member name="F:Library.Sender.symbolSize">
            <summary>
            The number of bytes in each symbol
            </summary>
        </member>
        <member name="M:Library.Sender.#ctor(Library.Symbol{System.Byte}[],Library.FountainCodeImplementations.IFountainCodeImplementation)">
            <summary>
            Sets up a new sender that will combine the given data according to the coefficients that come from the given function
            </summary>
            <param name="data"></param>
            <param name="implementation">An implementation that generates a boolean array of coefficients. The set bits indicate which data symbols get XOR'd together to generate an encoding symbol</param>
        </member>
        <member name="M:Library.Sender.GenerateNext(System.Int32@)">
            <summary>
            Generates a (probably unique) encoding symbol. The returned Tuple contains an array of bytes representing the index being encoded, and an array of encoded data. Each element of the encoded data has been encoded with sequential indices starting with the given index
            </summary>
            <param name="complexity">The number of operations that had to be performed</param>
            <returns></returns>
        </member>
        <member name="T:Library.Sender.Comparer">
            <summary>
            Allows duplicates
            </summary>
        </member>
        <member name="T:Library.Receiver">
            <summary>
            A class which collects enough encoding symbols (which are each the result of XOR'ing together particular symbols) to recover the original symbols
            </summary>
        </member>
        <member name="F:Library.Receiver.overhead">
            <summary>
            The number of additional symbols to wait for after receiving numSymbols of them before attempting to decode
            </summary>
        </member>
        <member name="F:Library.Receiver.numSymbols">
            <summary>
            The number of symbols that are in the original data
            </summary>
        </member>
        <member name="F:Library.Receiver.collectedEncodingSymbols">
            <summary>
            A record of all the encoding symbols that have been received so far
            </summary>
        </member>
        <member name="F:Library.Receiver.symbolSize">
            <summary>
            The number of bytes in each symbols
            </summary>
        </member>
        <member name="M:Library.Receiver.#ctor(System.Int32,System.Int64,System.Int32)">
            <summary>
            Creates a new solver
            </summary>
            <param name="numSymbols">The number of symbols that are in the original data we're trying to solve for</param>
            <param name="symbolSize">The number of bytes in each symbol</param>
            <param name="overhead">The number of encoding symbols to collect in addition to numSymbols</param>
        </member>
        <member name="M:Library.Receiver.Solve(System.Boolean[],Library.Symbol{System.Byte},System.Int32@)">
            <summary>
            Receives an encoding symbol, returning the decoded data if decoding was successful
            </summary>
            <param name="coefficients">The bits that are set indicate which symbols were XOR'd together to make this encoding symbol</param>
            <param name="value">The result of XOR'ing together symbols</param>
            <param name="complexity">The number of operations that had to be performed</param>
            <returns></returns>
        </member>
        <member name="T:Library.Symbol`1">
            <summary>
            Encapsulates an array things, allowing the XOR operator to be performed on them
            </summary>
        </member>
        <member name="F:Library.Symbol`1.Data">
            <summary>
            The encapsulated array of bytes
            </summary>
        </member>
        <member name="M:Library.Symbol`1.#ctor(`0[])">
            <summary>
            Creates a new Symbol from the given array of bytes
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:Library.Symbol`1.#ctor(System.Int64)">
            <summary>
            Creates a new symbol of the given order initialized to zero
            </summary>
            <param name="numBytes"></param>
        </member>
        <member name="M:Library.Symbol`1.GetUniformSize(Library.Symbol{`0}[])">
            <summary>
            Asserts that all the given symbols are the same size, returning that size
            </summary>
            <param name="symbols"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Symbol`1.op_Implicit(Library.Symbol{`0})~`0[]">
            <summary>
            Converts a symbol to an array of bytes
            </summary>
            <param name="symbol"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Symbol`1.op_Implicit(`0[])~Library.Symbol{`0}">
            <summary>
            Converts an array of bytes to a symbol
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Symbol`1.op_ExclusiveOr(Library.Symbol{`0},Library.Symbol{`0})">
            <summary>
            Performs the XOR operator on two symbols, returning a completely new symbol (doesn't modify either original symbol)
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="T:Library.Randomness.ThreadSafeRandom">
            <summary>
            A thread-safe implementation of Random, since Random isn't thread-safe by itself (https://msdn.microsoft.com/en-us/library/system.random#ThreadSafety)
            </summary>
        </member>
        <member name="M:Library.Randomness.ThreadSafeRandom.#ctor">
            <summary>
            Initializes a new instance of the System.Random class, using a time-dependent default seed value.
            </summary>
        </member>
        <member name="M:Library.Randomness.ThreadSafeRandom.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the System.Random class, using the specified seed value.
            </summary>
        </member>
        <member name="M:Library.Randomness.ThreadSafeRandom.Next">
            <summary>
            Returns a non-negative random integer.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Library.Randomness.ThreadSafeRandom.Next(System.Int32)">
            <summary>
            Returns a non-negative random integer that is less than the specified maximum.
            </summary>
            <param name="maxValue"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Randomness.ThreadSafeRandom.Next(System.Int32,System.Int32)">
            <summary>
            Returns a random integer that is within a specified range.
            </summary>
            <param name="minValue"></param>
            <param name="maxValue"></param>
            <returns></returns>
        </member>
        <member name="M:Library.Randomness.ThreadSafeRandom.NextBytes(System.Byte[])">
            <summary>
            Fills the elements of a specified array of bytes with random numbers.
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="M:Library.Randomness.ThreadSafeRandom.NextDouble">
            <summary>
            Returns a random floating-point number that is greater than or equal to 0.0, and less than 1.0.
            </summary>
            <returns></returns>
        </member>
    </members>
</doc>
